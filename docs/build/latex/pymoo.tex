%% Generated by Sphinx.
\def\sphinxdocclass{article}
\documentclass[letterpaper,10pt,english]{sphinxhowto}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{pymoo Documentation}
\date{Jun 25, 2018}
\release{0.1.2}
\author{Julian Blank}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


The test problems are uploaded to the PyPi Repository.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{pymoo}
\end{sphinxVerbatim}


\section{Implementations}
\label{\detokenize{index:implementations}}\label{\detokenize{index:installation}}

\subsection{Algorithms}
\label{\detokenize{index:algorithms}}
\sphinxstylestrong{Genetic Algorithm}: A simple genetic algorithm to solve
single-objective problems.

\sphinxstylestrong{NSGA-II} \phantomsection\label{\detokenize{index:id1}}{\hyperref[\detokenize{index:deb-2002-fem-2221359-2221582}]{\sphinxcrossref{{[}1{]}}}}: Non-dominated sorting genetic algorithm for
bi-objective problems. The mating selection is done using the binary
tournament by comparing the rank and the crowding distance. The crowding
distance is a niching measure in a two-dimensional space which sums up
the difference to the neighbours in each dimension. The non-dominated
sorting considers the rank determined by being in the ith front and the
crowding distance to achieve a good diversity when converging.

\sphinxstylestrong{NSGA-III} \phantomsection\label{\detokenize{index:id2}}{\hyperref[\detokenize{index:nsgaiii}]{\sphinxcrossref{{[}2{]}}}} \phantomsection\label{\detokenize{index:id3}}{\hyperref[\detokenize{index:nsgaiii-part2}]{\sphinxcrossref{{[}3{]}}}}: A referenced-based algorithm used to solve
many-objective problems. The survival selection uses the perpendicular
distance to the reference directions. As normalization the boundary
intersection method is used {[}5{]}.

\sphinxstylestrong{MOEAD/D} \phantomsection\label{\detokenize{index:id4}}{\hyperref[\detokenize{index:zhang07amulti-objective}]{\sphinxcrossref{{[}4{]}}}}: The classical MOEADD implementation using the
Tchebichew decomposition function.

\sphinxstylestrong{Differential Evolution} \phantomsection\label{\detokenize{index:id5}}{\hyperref[\detokenize{index:price-2005-dep-1121631}]{\sphinxcrossref{{[}5{]}}}}: The classical single-objective
differential evolution algorithm where different crossover variations
and methods can be defined. It is known for its good results for
effective global optimization.


\subsection{Methods}
\label{\detokenize{index:methods}}
\sphinxstylestrong{Simulated Binary Crossover} \phantomsection\label{\detokenize{index:id6}}{\hyperref[\detokenize{index:deb-2007-ssb-1276958-1277190}]{\sphinxcrossref{{[}6{]}}}}: This crossover simulates a
single-point crossover in a binary representation by using an
exponential distribution for real values. The polynomial mutation is
defined accordingly which performs basically a binary bitflip for real
numbers.


\section{Usage}
\label{\detokenize{index:usage}}
\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{time}

\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k}{import} \PYG{n}{animation}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}


\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}

    \PYG{c+c1}{\PYGZsh{} load the problem instance}
    \PYG{k+kn}{from} \PYG{n+nn}{pymop}\PYG{n+nn}{.}\PYG{n+nn}{zdt} \PYG{k}{import} \PYG{n}{ZDT1}
    \PYG{n}{problem} \PYG{o}{=} \PYG{n}{ZDT1}\PYG{p}{(}\PYG{n}{n\PYGZus{}var}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create the algorithm instance by specifying the intended parameters}
    \PYG{k+kn}{from} \PYG{n+nn}{pymoo}\PYG{n+nn}{.}\PYG{n+nn}{algorithms}\PYG{n+nn}{.}\PYG{n+nn}{NSGAII} \PYG{k}{import} \PYG{n}{NSGAII}
    \PYG{n}{algorithm} \PYG{o}{=} \PYG{n}{NSGAII}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{real}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{pop\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{n}{verbose}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{n}{start\PYGZus{}time} \PYG{o}{=} \PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} save the history in an object to observe the convergence over generations}
    \PYG{n}{history} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} number of generations to run it}
    \PYG{n}{n\PYGZus{}gen} \PYG{o}{=} \PYG{l+m+mi}{200}

    \PYG{c+c1}{\PYGZsh{} solve the problem and return the results}
    \PYG{n}{X}\PYG{p}{,} \PYG{n}{F}\PYG{p}{,} \PYG{n}{G} \PYG{o}{=} \PYG{n}{algorithm}\PYG{o}{.}\PYG{n}{solve}\PYG{p}{(}\PYG{n}{problem}\PYG{p}{,}
                              \PYG{n}{evaluator}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{100} \PYG{o}{*} \PYG{n}{n\PYGZus{}gen}\PYG{p}{)}\PYG{p}{,}
                              \PYG{n}{seed}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
                              \PYG{n}{return\PYGZus{}only\PYGZus{}feasible}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                              \PYG{n}{return\PYGZus{}only\PYGZus{}non\PYGZus{}dominated}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,}
                              \PYG{n}{history}\PYG{o}{=}\PYG{n}{history}\PYG{p}{)}

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}\PYGZhy{}\PYGZhy{} }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ seconds \PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{(}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{start\PYGZus{}time}\PYG{p}{)}\PYG{p}{)}

    \PYG{n}{scatter\PYGZus{}plot} \PYG{o}{=} \PYG{k+kc}{True}
    \PYG{n}{save\PYGZus{}animation} \PYG{o}{=} \PYG{k+kc}{True}

    \PYG{c+c1}{\PYGZsh{} get the problem dimensionality}
    \PYG{n}{is\PYGZus{}2d} \PYG{o}{=} \PYG{n}{problem}\PYG{o}{.}\PYG{n}{n\PYGZus{}obj} \PYG{o}{==} \PYG{l+m+mi}{2}
    \PYG{n}{is\PYGZus{}3d} \PYG{o}{=} \PYG{n}{problem}\PYG{o}{.}\PYG{n}{n\PYGZus{}obj} \PYG{o}{==} \PYG{l+m+mi}{3}

    \PYG{k}{if} \PYG{n}{scatter\PYGZus{}plot} \PYG{o+ow}{and} \PYG{n}{is\PYGZus{}2d}\PYG{p}{:}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

    \PYG{k}{if} \PYG{n}{scatter\PYGZus{}plot} \PYG{o+ow}{and} \PYG{n}{is\PYGZus{}3d}\PYG{p}{:}
        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{k+kn}{from} \PYG{n+nn}{mpl\PYGZus{}toolkits}\PYG{n+nn}{.}\PYG{n+nn}{mplot3d} \PYG{k}{import} \PYG{n}{Axes3D}
        \PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{111}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} create an animation to watch the convergence over time}
    \PYG{k}{if} \PYG{n}{is\PYGZus{}2d} \PYG{o+ow}{and} \PYG{n}{save\PYGZus{}animation}\PYG{p}{:}

        \PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{\PYGZus{}F} \PYG{o}{=} \PYG{n}{history}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{pf} \PYG{o}{=} \PYG{n}{problem}\PYG{o}{.}\PYG{n}{pareto\PYGZus{}front}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{pf}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{pf}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Pareto Front}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{n}{facecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{none}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{edgecolors}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{scat} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{\PYGZus{}F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{\PYGZus{}F}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}


        \PYG{k}{def} \PYG{n+nf}{update}\PYG{p}{(}\PYG{n}{frame\PYGZus{}number}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{\PYGZus{}F} \PYG{o}{=} \PYG{n}{history}\PYG{p}{[}\PYG{n}{frame\PYGZus{}number}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
            \PYG{n}{scat}\PYG{o}{.}\PYG{n}{set\PYGZus{}offsets}\PYG{p}{(}\PYG{n}{\PYGZus{}F}\PYG{p}{)}

            \PYG{c+c1}{\PYGZsh{} get the bounds for plotting and add padding}
            \PYG{n+nb}{min} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{min}\PYG{p}{(}\PYG{n}{\PYGZus{}F}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mf}{0.1}
            \PYG{n+nb}{max} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{max}\PYG{p}{(}\PYG{n}{\PYGZus{}F}\PYG{p}{,} \PYG{n}{axis}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mf}{0.}

            \PYG{c+c1}{\PYGZsh{} set the scatter object with padding}
            \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
            \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}


        \PYG{c+c1}{\PYGZsh{} create the animation}
        \PYG{n}{ani} \PYG{o}{=} \PYG{n}{animation}\PYG{o}{.}\PYG{n}{FuncAnimation}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{update}\PYG{p}{,} \PYG{n}{frames}\PYG{o}{=}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n\PYGZus{}gen}\PYG{p}{)}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} write the file}
        \PYG{n}{Writer} \PYG{o}{=} \PYG{n}{animation}\PYG{o}{.}\PYG{n}{writers}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ffmpeg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
        \PYG{n}{writer} \PYG{o}{=} \PYG{n}{Writer}\PYG{p}{(}\PYG{n}{fps}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n}{bitrate}\PYG{o}{=}\PYG{l+m+mi}{1800}\PYG{p}{)}
        \PYG{n}{ani}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{.mp4}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{problem}\PYG{o}{.}\PYG{n}{name}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{writer}\PYG{o}{=}\PYG{n}{writer}\PYG{p}{)}
\end{sphinxVerbatim}


\section{References}
\label{\detokenize{index:references}}



\section{API}
\label{\detokenize{index:api}}

\section{Contact}
\label{\detokenize{index:contact}}
Feel free to contact me if you have any question:

\begin{DUlineblock}{0em}
\item[] Julian Blank (blankjul {[}at{]} egr.msu.edu)
\item[] Michigan State University
\item[] Computational Optimization and Innovation Laboratory (COIN)
\item[] East Lansing, MI 48824, USA
\end{DUlineblock}

\begin{sphinxthebibliography}{1}
\bibitem[1]{\detokenize{1}}{\phantomsection\label{\detokenize{index:deb-2002-fem-2221359-2221582}} 
K. Deb, A. Pratap, S. Agarwal, and T. Meyarivan. A fast and elitist multiobjective genetic algorithm: nsga-ii. \sphinxstyleemphasis{Trans. Evol. Comp}, 6(2):182\textendash{}197, April 2002. URL: \sphinxurl{http://dx.doi.org/10.1109/4235.996017}, \sphinxhref{https://doi.org/10.1109/4235.996017}{doi:10.1109/4235.996017}.
}
\bibitem[2]{\detokenize{2}}{\phantomsection\label{\detokenize{index:nsgaiii}} 
Kalyanmoy Deb and Himanshu Jain. An evolutionary many-objective optimization algorithm using reference-point-based nondominated sorting approach, part i: solving problems with box constraints. \sphinxstyleemphasis{IEEE Transactions on Evolutionary Computation}, 18(4):577\textendash{}601, 2014. \sphinxhref{https://doi.org/10.1109/TEVC.2013.2281535}{doi:10.1109/TEVC.2013.2281535}.
}
\bibitem[3]{\detokenize{3}}{\phantomsection\label{\detokenize{index:nsgaiii-part2}} 
K. Deb and H. Jain. An evolutionary many-objective optimization algorithm using reference-point-based nondominated sorting approach, part i: solving problems with box constraints. \sphinxstyleemphasis{IEEE Transactions on Evolutionary Computation}, 18(4):577\textendash{}601, Aug 2014. \sphinxhref{https://doi.org/10.1109/TEVC.2013.2281535}{doi:10.1109/TEVC.2013.2281535}.
}
\bibitem[4]{\detokenize{4}}{\phantomsection\label{\detokenize{index:zhang07amulti-objective}} 
Qingfu Zhang and Hui Li. A multi-objective evolutionary algorithm based on decomposition. \sphinxstyleemphasis{IEEE Transactions on Evolutionary Computation, Accepted}, 2007.
}
\bibitem[5]{\detokenize{5}}{\phantomsection\label{\detokenize{index:price-2005-dep-1121631}} 
Kenneth Price, Rainer M. Storn, and Jouni A. Lampinen. \sphinxstyleemphasis{Differential Evolution: A Practical Approach to Global Optimization (Natural Computing Series)}. Springer-Verlag, Berlin, Heidelberg, 2005. ISBN 3540209506.
}
\bibitem[6]{\detokenize{6}}{\phantomsection\label{\detokenize{index:deb-2007-ssb-1276958-1277190}} 
Kalyanmoy Deb, Karthik Sindhya, and Tatsuya Okabe. Self-adaptive simulated binary crossover for real-parameter optimization. In \sphinxstyleemphasis{Proceedings of the 9th Annual Conference on Genetic and Evolutionary Computation}, GECCO ‘07, 1187\textendash{}1194. New York, NY, USA, 2007. ACM. URL: \sphinxurl{http://doi.acm.org/10.1145/1276958.1277190}, \sphinxhref{https://doi.org/10.1145/1276958.1277190}{doi:10.1145/1276958.1277190}.
}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}